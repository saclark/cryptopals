package exploit

import "fmt"

// DetectECBMode returns a number in the range [0, 1] indicating the fraction of
// ciphertext blocks that are duplicated. A higher score indicates a higher
// likelihood that the ciphertext was encrypted with ECB. It panics if
// ciphertext is not a multiple of BlockSize.
func DetectECBMode(ciphertext []byte, blockSize int) float64 {
	if len(ciphertext) == 0 {
		return 0
	}

	if len(ciphertext)%blockSize != 0 {
		panic("aes.DetectECB: ciphertext size not a multiple of block size")
	}

	var duped int
	n := len(ciphertext) / blockSize
	seen := make(map[string]bool, n)
	for i := 0; i+blockSize <= len(ciphertext); i += blockSize {
		if duplicated, ok := seen[string(ciphertext[i:i+blockSize])]; ok {
			if !duplicated {
				duped += 2
				seen[string(ciphertext[i:i+blockSize])] = true
			} else {
				duped++
			}
		} else {
			seen[string(ciphertext[i:i+blockSize])] = false
		}
	}

	return float64(duped) / float64(n)
}

// IsOracleECBMode detects whether an encryption oracle is using ECB mode.
func IsOracleECBMode(blockSize int, encrypt EncryptionOracle) (bool, error) {
	ecbProbe := make([]byte, blockSize*blockSize)
	ciphertext, err := encrypt(ecbProbe)
	if err != nil {
		return false, fmt.Errorf("calling encrypt: %v", err)
	}
	score := DetectECBMode(ciphertext[:len(ecbProbe)], blockSize)
	return score > 0, nil
}
