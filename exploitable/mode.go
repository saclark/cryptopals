package exploitable

import (
	"crypto/rand"
	"fmt"
	"math/big"

	"github.com/saclark/cryptopals-go/aes"
	"github.com/saclark/cryptopals-go/pkcs7"
)

// NewModeDetectionOracle creates an encryption oracle that will add 5-10 bytes
// to both the beginning and end of it's input and then encrypt that using AES
// with a different random mode, key, and IV (if CBC mode), upon each
// invocation. When not nil, handleIsECB will be called upon each invocation of
// the oracle, passing in a boolean indicating whether ECB mode was chosen.
func NewModeDetectionOracle(handleIsECB func(bool)) (oracle func([]byte) ([]byte, error), err error) {
	oracle = func(input []byte) ([]byte, error) {
		isECB, err := randomBool()
		if err != nil {
			return nil, fmt.Errorf("choosing random mode: %w", err)
		}
		if handleIsECB != nil {
			handleIsECB(isECB)
		}
		key, err := randomBlock(aes.BlockSize)
		if err != nil {
			return nil, fmt.Errorf("generating random key: %w", err)
		}
		plaintext, err := junkifyAndPad(input)
		if err != nil {
			return nil, fmt.Errorf("junkifying and padding input: %w", err)
		}
		if isECB {
			return aes.EncryptECB(plaintext, key)
		}
		iv, err := randomBlock(aes.BlockSize)
		if err != nil {
			return nil, fmt.Errorf("generating random IV: %v", err)
		}
		return aes.EncryptCBC(plaintext, key, iv)
	}
	return oracle, nil
}

func junkifyAndPad(input []byte) ([]byte, error) {
	randInt, err := rand.Int(rand.Reader, big.NewInt(6))
	if err != nil {
		return nil, fmt.Errorf("generating random int in range [0,6): %v", err)
	}

	n := int(randInt.Int64() + 5)
	b := byte(n)

	junkified := make([]byte, len(input)+n*2)
	copy(junkified[n:len(junkified)-n], input)

	for i := 0; i < n; i++ {
		junkified[i], junkified[len(junkified)-1-i] = b, b
	}

	return pkcs7.Pad(junkified, aes.BlockSize), nil
}
